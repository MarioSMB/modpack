#pragma once

// special spawn flags
const int MON_FLAG_APPEAR = BIT(0);
// BIT(1) unused
// BIT(2) unused
// BIT(3) unused
const int MON_FLAG_NOAGGRO = BIT(4); // not aggro'd by enemy attacks
const int MONSTER_TYPE_FLY = BIT(5);
const int MONSTER_TYPE_SWIM = BIT(6);
const int MONSTER_TYPE_BOSS = BIT(7);
const int MON_FLAG_EXPLOSIONRESISTANT = BIT(8); // takes half damage from explosions
const int MON_FLAG_STATIONARY = BIT(9); // monster cannot move
const int MON_FLAG_METAL = BIT(10); // is a full metal soldier
const int MON_FLAG_INFIGHT = BIT(11); // monster will fight even its own species
const int MON_FLAG_PASSTARGET = BIT(12); // monster will run right through its target, useful for bumping into them
const int MON_FLAG_NOTARGET = BIT(13); // monster should not be targeted at all by other monsters
const int MONSTER_TYPE_DECOY = BIT(14); // hipnotic flag for decoy monsters
const int MONSTER_TYPE_UNDEAD = BIT(15); // monster is by most definitions a zombie (doesn't fully die unless gibbed)
const int MON_FLAG_HIDDEN = BIT(16);
const int MON_FLAG_XMAS = BIT(17); // seasonal monster
const int MON_FLAG_LOOKAT = BIT(18); // must be looking at the monster for it to aggro
const int MON_FLAG_IGNOREPLAYER = BIT(19); // doesn't automatically aggro unless attacked
const int MON_FLAG_BLOCKY = BIT(20); // from a blocky world, excludes from random selection

// entity properties of monsterinfo:
.entity monsterdef;

CLASS(Monster, Object)
    ATTRIB(Monster, monsterid, int, 0);
    /** attributes */
    ATTRIB(Monster, spawnflags, int, 0);
    /** human readable name */
    ATTRIB(Monster, m_name, string, "Monster");
    /** concise description */
    ATTRIB(Monster, m_description, string, "");
    /** short name */
    ATTRIB(Monster, netname, string, "");
    /** model */
    ATTRIB(Monster, m_model, entity);
    /** sightsound */
    ATTRIB(Monster, m_sound, Sound, SND_Null);
    /** head model */
    ATTRIB(Monster, m_model_head, entity);
    /** hitbox size */
    ATTRIB(Monster, m_mins, vector, '-0 -0 -0');
    /** hitbox size */
    ATTRIB(Monster, m_maxs, vector, '0 0 0');
    /** waypoint offset (overrides if set) */
    ATTRIB(Monster, view_ofs, vector, '0 0 0');
    /** health bar color (bosses only) */
    ATTRIB(Monster, m_color, vector, '0 0 0');

    /** (SERVER) setup monster data */
    /* in quake, most functions are stored as entity properties */
    METHOD(Monster, mr_setup, bool(Monster this, entity actor)) { TC(Monster, this); return false; }
    /** (SERVER) called when a monster spots a target, return false to not hunt the target */
    METHOD(Monster, mr_sight, bool(Monster this, entity actor))
    {
        TC(Monster, this);
        if(this.m_sound != SND_Null)
            sound(actor, CH_VOICE, this.m_sound, 1, ATTN_NORM);
        return true;
    }

ENDCLASS(Monster)

#ifdef SVQC
#include "../../server/client.qh"
#include "../../server/combat.qh"
#include "../../server/items.qh"
#include "../../server/monsters/ai.qh"
#include "../../server/monsters/fight.qh"
#include "../../server/monsters/monsters.qh"
#include "../../server/monsters/ai_rogue.qh"
#include "../../server/weapons.qh"
#endif
#ifdef GAMEQC
#include "../models/all.qh"
#include "../items/item.qh"
#endif
