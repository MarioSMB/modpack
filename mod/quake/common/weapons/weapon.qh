#pragma once

USING(WepSet, vector);

const int MAX_WEAPONSLOTS = 2;
.entity weaponentities[MAX_WEAPONSLOTS];

int weaponslot(.entity weaponentity)
{
    for (int i = 0; i < MAX_WEAPONSLOTS; ++i)
    {
        if (weaponentities[i] == weaponentity)
        {
            return i;
        }
    }
    return 0;
}

/** fields which are explicitly/manually set are marked with "M", fields set automatically are marked with "A" */
CLASS(Weapon, Object)
	ATTRIB(Weapon, m_id, int, 0);
    /** M: ammotype  : main ammo type */
    ATTRIB(Weapon, ammo_type, int, 0);
    /** M: impulse   : weapon impulse */
    ATTRIB(Weapon, impulse, int, -1);
    /** M: flags     : WEPSPAWNFLAG_... combined */
    ATTRIB(Weapon, spawnflags, int, 0);
    /** M: ammo      : amount of ammo rewarded for picking up the weapon */
    ATTRIB(Weapon, aflag, int, 0);
    /** M: modelname : name of model (without g_ v_ or h_ prefixes) */
    ATTRIB(Weapon, mdl, string, "");
    /** M: crosshair : per-weapon crosshair: "CrosshairImage Size" */
    ATTRIB(Weapon, w_crosshair, string, "gfx/crosshairmoustache");
    /** A: crosshair : per-weapon crosshair size (argument two of "crosshair" field) */
    ATTRIB(Weapon, w_crosshair_size, float, 1);
    /** A: crosshair : per-weapon crosshair color (argument three of "crosshair" field) */
    ATTRIB(Weapon, w_crosshair_color, vector, '0 0 0');
    /** M: wepimg    : "weaponfoobar" side view image file of weapon. WEAPONTODO: Move out of skin files, move to common files */
    ATTRIB(Weapon, model2, string, "");
    /** M: refname   : reference name name */
    ATTRIB(Weapon, netname, string, "");
    /** M: replace   : reference replacement name */
    ATTRIB(Weapon, weaponreplace, string, "");
    /** M: wepname   : human readable name */
    ATTRIB(Weapon, m_name, string, "AOL CD Thrower");
#ifdef GAMEQC
    /** M: sound SND_id_MUSICNOTE */
    ATTRIB(Weapon, m_musicnote, entity);
    /** M: pitch     : whether this weapon should have no pitch adjustments as an instrument */
    ATTRIB(Weapon, m_nopitch, bool, false);
#endif


    /** (SERVER) setup weapon data */
    METHOD(Weapon, wr_setup, void(Weapon this, entity actor)) {}
    /** (SERVER) logic to run every frame */
    METHOD(Weapon, wr_think, void(Weapon this, entity actor, .entity weaponentity, int fire)) {}
    /** (SERVER) checks ammo for weapon primary */
    METHOD(Weapon, wr_checkammo1, bool(Weapon this, entity actor, .entity weaponentity)) {return false;}
    /** (BOTH)   precaches models/sounds used by this weapon, also sets up weapon properties */
    METHOD(Weapon, wr_init, void(Weapon this)) {}
    /** (SERVER) notification number for suicide message (may inspect w_deathtype for details) */
    METHOD(Weapon, wr_suicidemessage, entity(Weapon this)) {return NULL;}
    /** (SERVER) notification number for kill message (may inspect w_deathtype for details) */
    METHOD(Weapon, wr_killmessage, entity(Weapon this)) {return NULL;}
    /** (CLIENT) impact effect for weapon explosion */
    METHOD(Weapon, wr_impacteffect, void(Weapon this, entity actor)) {}
    METHOD(Weapon, wr_viewmodel, string(Weapon this, entity wep)) { return string_null; }
    /** (CLIENT) framerate of the weapon animations, uses regular setting if 0 */
    ATTRIB(Weapon, m_delta, float, 0);
    /** (SERVER) weapon frame to use during parrying TODO: support actual animations? */
    ATTRIB(Weapon, m_parryframe, int, 1);
ENDCLASS(Weapon)

// weapon flags
#if 0
const int WEP_TYPE_OTHER          =  BIT(0); // not for damaging people
const int WEP_TYPE_SPLASH         =  BIT(1); // splash damage
const int WEP_TYPE_HITSCAN        =  BIT(2); // hitscan
const int WEP_FLAG_CANCLIMB       =  BIT(3); // can be used for movement
const int WEP_FLAG_NORMAL         =  BIT(4); // in "most weapons" set
const int WEP_FLAG_HIDDEN         =  BIT(5); // hides from menu
const int WEP_FLAG_RELOADABLE     =  BIT(6); // can has reload
const int WEP_FLAG_SUPERWEAPON    =  BIT(7); // powerup timer
const int WEP_FLAG_MUTATORBLOCKED =  BIT(8); // hides from impulse 99 etc. (mutators are allowed to clear this flag)
const int WEP_TYPE_MELEE_PRI      =  BIT(9); // primary attack is melee swing (for animation)
const int WEP_TYPE_MELEE_SEC      =  BIT(10); // secondary attack is melee swing (for animation)
#endif
const int WEP_FLAG_NOALTERNATE   =  BIT(0); // weapon is always fired at the same rate even when dual wielded
const int WEP_FLAG_MANA          =  BIT(1); // weapon uses mana instead of ammo
const int WEP_FLAG_DUALWIELD     =  BIT(2); // weapon can be dual wielded
const int WEP_FLAG_NODUAL        =  BIT(3); // weapon doesn't work well with dual wielding (fireball etc just explode on fire), doesn't currently prevent anything
const int WEP_FLAG_HUDFALLBACK   =  BIT(4); // weapon is displayed in the HUD as a default if no other weapon in the slot is selected
const int WEP_FLAG_TWOHANDED     =  BIT(5); // weapon must be wielded with two hands (generally means it has a secondary attack)
const int WEP_FLAG_NOAGGRO       =  BIT(6); // weapon does not aggro nearby monsters when used
const int WEP_FLAG_HITUNDEAD     =  BIT(7); // weapon can bypass the undead's ability to shrug off attacks
const int WEP_FLAG_MELEE         =  BIT(9); // attack is melee swing (for animation)
const int WEP_FLAG_NOSTEAL       =  BIT(10); // weapon should not be taken by gremlins
const int WEP_FLAG_HIPNOTIC      =  BIT(11); // from the hipnotic mission pack
const int WEP_FLAG_ROGUE         =  BIT(12); // from the rogue mission pack
const int WEP_FLAG_IMPEL         =  BIT(13); // from the impel mission pack
const int WEP_FLAG_MUSIC         =  BIT(14); // weapon is a musical instrument
const int WEP_FLAG_CHAMPION      =  BIT(15); // weapon is a champion's signature weapon
const int WEP_FLAG_SWAB          =  BIT(16); // from the swab campaign

// variables:
string weaponorder_byid;

// functions:
string W_FixWeaponOrder(string order, float complete);
string W_NameWeaponOrder(string order);
string W_NumberWeaponOrder(string order);
string W_FixWeaponOrder_BuildImpulseList(string o);
string W_FixWeaponOrder_AllowIncomplete(entity this, string order);
string W_FixWeaponOrder_ForceComplete(string order);

#ifdef SVQC

void weapon_defaultspawnfunc(entity this, Weapon e);
#define SPAWNFUNC_WEAPON(name, weapon) \
    spawnfunc(name) { weapon_defaultspawnfunc(this, weapon); }

#define SPAWNFUNC_WEAPON_COND(name, cond, wep1, wep2) \
	SPAWNFUNC_WEAPON(name, (cond ? wep1 : wep2))

#else

#define SPAWNFUNC_WEAPON(name, weapon)

#endif

#ifdef SVQC
#include "../notifications/all.qh"
#include "../../server/items.qh"
#include "../../server/player.qh"
#include "../../server/rogue/lava_wpn.qh"
#include "../../common/triggers/triggers.qh"
#include "../../server/weapons.qh"
#include "../../server/weapons/common.qh"
#endif

#ifdef GAMEQC
#include "../items/item.qh"
#include "../models/all.qh"
#endif
