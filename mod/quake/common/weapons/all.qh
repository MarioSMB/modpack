#pragma once

#include "weapon.qh"

#ifdef GAMEQC
#include "projectiles.qh"
#endif

#ifdef GAMEQC
// TODO: cleaner way to list these?
noref string autocvar_cl_quake_weaponpriority = "smg breegull plane magic shield gravgun mushroom pogo rocketlauncher multirocketlauncher driller impaler nuke cannon lightning plasma shock lightme railgun otamatone laser_gun mic grenadelauncher multigrenade proximitygun tuba napalm fish chimes mayo spellbook hammer portalgun ocarina supernailgun lavasupernailgun organ crossbow piano sshotgun ripper doot nailgun lavanailgun biogun kazoo shotgun banjo ball katana sword crowbar meowmere wand chainsaw pan axe bongos";
noref bool autocvar_cl_quake_weaponpriority_useforcycling = false;
noref string autocvar_cl_quake_weaponpriority0 = "rocketlauncher nuke cannon multirocketlauncher driller impaler grenadelauncher multigrenade biogun proximitygun tuba napalm fish mayo"; // explosives
noref string autocvar_cl_quake_weaponpriority1 = "lightning plasma shock lightme railgun"; // energy
noref string autocvar_cl_quake_weaponpriority2 = "lightning portalgun"; // hitscan exact
noref string autocvar_cl_quake_weaponpriority3 = "lightning sshotgun shotgun"; // hitscan all
noref string autocvar_cl_quake_weaponpriority4 = "smg laser_gun shock grenadelauncher multigrenade napalm fish mayo ocarina supernailgun biogun tuba lavasupernailgun crossbow piano doot nailgun lavanailgun bongos kazoo chainsaw"; // spam weapons
noref string autocvar_cl_quake_weaponpriority5 = "nuke cannon impaler portalgun"; // movement weapons
noref string autocvar_cl_quake_weaponpriority6 = "tuba mic ocarina otamatone banjo bongos chimes mayo piano kazoo doot"; // musical instruments
noref string autocvar_cl_quake_weaponpriority7 = "";
noref string autocvar_cl_quake_weaponpriority8 = "";
noref string autocvar_cl_quake_weaponpriority9 = "";
noref int autocvar_cl_quake_weaponimpulsemode = 0;
noref bool autocvar_cl_quake_weapon_switch_fallback_to_impulse = true;
#endif

#ifdef SVQC
void player_shot1(entity this);
void wep_generic_shot1(entity this);
void player_rocket1(entity this);
void wep_generic_rocket1(entity this);
void player_nail1(entity this);
void player_light1(entity this);
#endif

int W_GunAlign(entity this, int preferred_align);

#ifdef SVQC
void WriteWepSet(float dest, WepSet w);
#endif

#ifdef CSQC
WepSet WepSet_GetFromStat();
WepSet ReadWepSet();
#endif

#include "../util.qh"

REGISTRY(Weapons, 72) // Increase as needed. Can be up to 72.
REGISTER_REGISTRY(Weapons)

.WepSet m_wepset;
#define WEPSET(id) (WEP_##id.m_wepset)
#define WepSet_FromWeapon(it) ((it).m_wepset)
WepSet _WepSet_FromWeapon(int i);

#define REGISTER_WEAPON(...) EVAL_REGISTER_WEAPON(OVERLOAD(REGISTER_WEAPON, __VA_ARGS__))
#define EVAL_REGISTER_WEAPON(...) __VA_ARGS__
#define REGISTER_WEAPON_2(id, inst) REGISTER(Weapons, WEP, id, m_id, inst)

REGISTER_WEAPON(Null, NEW(Weapon));
REGISTRY_DEFINE_GET(Weapons, WEP_Null)

Weapon Weapon_from_name(string s)
{
    FOREACH(Weapons, it != WEP_Null && it.netname == s, return it);
    return WEP_Null;
}

const int WEP_FIRST = 1;
#define WEP_LAST (REGISTRY_COUNT(Weapons) - 1)
WepSet WEPSET_ALL;
WepSet WEPSET_CHAMPIONS;

#include "all.inc"

// TODO: invert after changes have been made to the hardcoded weapon impulses. Will require moving 'best weapon' impulses
#define WEP_IMPULSE_BEGIN 230
#define WEP_IMPULSE_END bound(WEP_IMPULSE_BEGIN, WEP_IMPULSE_BEGIN + (REGISTRY_COUNT(Weapons) - 1) - 1, 253)

REGISTRY_SORT(Weapons, WEP_HARDCODED_IMPULSES + 1)
REGISTRY_CHECK(Weapons)

STATIC_INIT(register_weapons_done)
{
    string inaccessible = "";
    FOREACH(Weapons, true, {
        WepSet set = it.m_wepset = _WepSet_FromWeapon(it.m_id = i);
        WEPSET_ALL |= set;
        if (it.spawnflags & WEP_FLAG_CHAMPION)
            WEPSET_CHAMPIONS |= set;
        if (it == WEP_Null) continue;
        int imp = WEP_IMPULSE_BEGIN + it.m_id - 1;
        if (imp <= WEP_IMPULSE_END)
            localcmd(sprintf("alias weapon_%s \"impulse %d\"\n", it.netname, imp));
        else
            inaccessible = strcat(inaccessible, "\n", it.netname);
    });
    if (inaccessible != "" && autocvar_developer > 0) LOG_TRACEF("Impulse limit exceeded, weapon(s) will not be directly accessible: %s", inaccessible);
    weaponorder_byid = "";
    for (int i = REGISTRY_MAX(Weapons) - 1; i >= 1; --i)
        if (REGISTRY_GET(Weapons, i))
            weaponorder_byid = strcat(weaponorder_byid, " ", ftos(i));
    weaponorder_byid = strzone(substring(weaponorder_byid, 1, -1));
}

REPLICATE_INIT(bool, cvar_cl_weapon_switch_fallback_to_impulse);
REPLICATE_INIT(int, cvar_cl_weaponimpulsemode);

REPLICATE_INIT(string, cvar_cl_weaponpriority);
REPLICATE_INIT(string, cvar_cl_weaponpriorities[10]);

#ifdef GAMEQC
.string weaponname; // name of .weapon

.vector movedir_aligned; // shot origin based on weapon alignment (unaffected by shootfromeye)

.int m_gunalign;

vector shotorg_adjust_values(vector vecs, float algn);
void CL_WeaponEntity_SetModel(entity this, string name);
#endif

#ifdef SVQC
string W_FixWeaponOrder_ForceComplete_AndBuildImpulseList(entity this, string wo);
string W_FixWeaponOrder_AllowIncomplete(entity this, string order);
#endif
