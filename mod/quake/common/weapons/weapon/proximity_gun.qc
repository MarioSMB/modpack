#include "proximity_gun.qh"

#ifdef SVQC
#include "../../../common/triggers/func/spawn.qh"
#endif

#ifdef SVQC
void ProximityExplode(entity this)
{
	T_RadiusDamage(this, this.owner, 95, this.projectiledeathtype, NULL);

	Send_Effect(EFFECT_EXPLOSION, this.origin, '0 0 0', 1);
	sound(this, CH_WEAPON_SINGLE, SND_ROCKET_EXPLOSION, 1, ATTN_NORM);

	BecomeExplosion(this);
}

void ProximityGrenadeExplode(entity this, entity inflictor, entity attacker, int deathtype)
{
	this.takedamage = DAMAGE_NO;
	this.realowner.NumProximityGrenades -= 1;
	this.nextthink = time + 0.1;
	this.state = 2;
	this.owner = this.lastvictim;
	setthink(this, ProximityExplode);
}

void ProximityGrenadeTouch(entity this, entity toucher)
{
	if(toucher == this)
		return;
	if(toucher.classname == this.classname)
		return;
	set_movetype(this, MOVETYPE_TOSS);
	if(this.state == 1)
		return;
	if(vdist(toucher.velocity, >, 0) || toucher.takedamage == DAMAGE_AIM)
	{
		ProximityGrenadeExplode(this, NULL, NULL, 0);
		getthink(this)(this);
		return;
	}
	_sound(this, CH_WEAPON_SINGLE, "weapons/bounce.wav", 1, ATTN_NORM); // bounce sound
	set_movetype(this, MOVETYPE_NONE);
	setsize(this, '-8 -8 -8', '8 8 8');
	this.state = 1;
	this.spawnmaster = toucher;
}

void ProximityBomb(entity this)
{
	if((time > this.delay) || (this.realowner.NumProximityGrenades > 15) || vdist(this.spawnmaster.velocity, >, 0) )
	{
		ProximityGrenadeExplode(this, NULL, NULL, 0);
		getthink(this)(this);
		return;
	}
	this.owner = NULL;
	this.takedamage = DAMAGE_YES;
	entity head = findradius(this.origin, 140);
	bool blowup = false;

	while(head)
	{
		if(head != this && head.health > 0 && (IS_PLAYER(head) || IS_MONSTER(head)) && head.classname != this.classname && head != this.realowner)
			blowup = true;
		if((head.classname == this.classname) && (head.state == 0) && head.realowner != this.realowner)
			blowup = true;
		traceline(this.origin, head.origin, MOVE_NOMONSTERS, this);
		if(trace_fraction != 1.0)
			blowup = false;
		if(blowup)
		{
			_sound(this, CH_WEAPON_SINGLE, "hipweap/proxwarn.wav", 1, ATTN_NORM);
			ProximityGrenadeExplode(this, NULL, NULL, 0);
			this.nextthink = time + 0.5;
			return;
		}
		head = head.chain;
	}
	this.nextthink = time + 0.25;
}

void W_FireProximityGrenade(entity this, .entity weaponentity)
{
	this.NumProximityGrenades += 1;
	W_TakeAmmo(this, ammo_rockets, 1);

	_sound(this, CH_WEAPON_SINGLE, "hipweap/proxbomb.wav", 1, ATTN_NORM);

	this.punchangle_x = -2;

	entity missile = spawn();
	missile.flags = FL_PROJECTILE;
	missile.owner = missile.realowner = this;
	missile.lastvictim = this;
	set_movetype(missile, MOVETYPE_TOSS);
	missile.solid = SOLID_BBOX;
	missile.classname = "proximity_grenade";
	missile.takedamage = DAMAGE_NO;
	missile.health = 5;
	missile.state = 0;
	missile.projectiledeathtype = WEP_PROXIMITY_GUN.m_id;
	missile.clipgroup = this.clipgroup;

// set missile speed

	makevectors(this.v_angle);

	if(this.v_angle_x)
		missile.velocity = v_forward * 600 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
	else
	{
		missile.velocity = qc_aim(this, 10000);
		missile.velocity = missile.velocity * 600;
		missile.velocity_z = 200;
	}

	missile.avelocity = '100 600 100';

	missile.angles = vectoangles(missile.velocity);

	settouch(missile, ProximityGrenadeTouch);

// set missile duration
	missile.nextthink = time + 2;
	missile.delay = time + 15 +(10*random());
	setthink(missile, ProximityBomb);
	missile.th_die = ProximityGrenadeExplode;

	_setmodel(missile, "progs/proxbomb.mdl");
	setorigin(missile, W_Shotorg(this, weaponentity));
	setsize(missile, '-1 -1 -1', '1 1 1');

	IL_PUSH(g_projectiles, missile);
}

void W_Proximity_Detonate(entity this, .entity weaponentity)
{
	bool didexplode = false;
	FOREACH_ENTITY_CLASS("proximity_grenade", it.realowner == this && it.state == 1,
	{
		ProximityGrenadeExplode(it, NULL, NULL, 0);
		didexplode = true;
	});

	if(didexplode)
		_sound(this, CH_WEAPON_SINGLE, "hipweap/proxwarn.wav", 1, ATTN_NORM);
}

METHOD(ProximityGun, wr_think, void(entity thiswep, entity actor, .entity weaponentity, int fire))
{
	if(fire & 1)
	if(!(time < ATTACK_FINISHED(actor, weaponentity)))
	if(thiswep.wr_checkammo1(thiswep, actor, weaponentity))
	{
		if(IS_PLAYER(actor))
			player_rocket1(actor);
		wep_generic_rocket1(actor.(weaponentity));
		W_FireProximityGrenade(actor, weaponentity);
		weapon_prepareattack(thiswep, actor, weaponentity, 0.6);
	}

	if(fire & 2)
	if(!(time < ATTACK_FINISHED(actor, weaponentity)))
	{
		W_Proximity_Detonate(actor, weaponentity);
		weapon_prepareattack(thiswep, actor, weaponentity, 0.6);
	}
}
METHOD(ProximityGun, wr_checkammo1, bool(entity thiswep, entity actor, .entity weaponentity))
{
	float ammo_amount = actor.ammo_rockets >= 1;
	return ammo_amount;
}
METHOD(ProximityGun, wr_suicidemessage, Notification(entity thiswep))
{
    return WEAPON_THINKING_WITH_PORTALS;
}
METHOD(ProximityGun, wr_killmessage, Notification(entity thiswep))
{
	return WEAPON_FRAG;
}
#endif
