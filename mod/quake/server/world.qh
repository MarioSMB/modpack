#pragma once

float autocvar_fraglimit;
bool autocvar__endmatch;
int autocvar_skill;
bool autocvar_sv_curl_serverpackages_auto;
string autocvar_sessionid;

float autocvar_sv_quake_matchlimit = 2880;
string autocvar_sv_quake_maplist = "";
float autocvar_sv_quake_timelimit = 15;
float autocvar_sv_quake_fraglimit = 20;

// protocol bytes
const int SVC_CUTSCENE = 34;

const int DROPTOFLOOR_DISABLE = 65536;

float sys_frametime;     // gets initialised in worldspawn, saves the value from autocvar_sys_ticrate

float servertime, serverprevtime, serverframetime;

int startingserverflags;

const string QUAKE_TALKSOUND = "misc/quake_talk.wav";

int intermission_running;

bool gameover;

.string endtext;

.bool jump_flag;

.bool nightmare_checked;

// copper junk
// mostly unused unless necessary for compat
.int customflags;
const int CFL_LEFTY = 1;	// used by slidemovers (scrags) to alternate strafe direction
const int CFL_RETURNED = 1;	// zombie has already respawned in nightmare
const int CFL_INVLIGHT = 1;	// for backwards bmover light fade behavior
const int CFL_ZAPPED = 2;
const int CFL_AXEHITME = 4;
const int CFL_LOCKED = 16;	// special state-independent deactivation
const int CFL_INPAIN = 16;	// zombie should knockdown soon
const int CFL_KNOCKEDDOWN = 32;	// zombie is down
const int CFL_PLUNGE = 64;	// has fallen in a death pit
const int CFL_SPAWNER = 128;	// is a generator of monsters
const int CFL_UNDYING = 256;	// god mode minus one point (player)
const int CFL_LIQUID_IMMUNE = 512;	// monster spawned touching slime or lava, so assume designer wants it immune to damage
const int CFL_MELEEONLY = 1024;	// has no ranged attack (monster)
const int CFL_LIMBO = 2048;	// waiting in teleport limbo (coop, player)
const int CFL_OMNIVISION = 4096;	// eyes in back of head

void bmodel_lightstyle(entity b, float opacity);

// impel stuff
bool angry_monsters;
bool corpse_removal;
.entity other2;

bool world_already_spawned;
int world_initialized;
bool server_is_dedicated;

// database
float ServerProgsDB;

bool IsRogueMap();

bool IsMGMap();

bool MoveToRandomLocationWithinBounds(entity e, vector boundmin, vector boundmax, float goodcontents, float badcontents, float badsurfaceflags, int attempts, float maxaboveground, float minviewdistance, bool frompos);
bool MoveToRandomMapLocation(entity e, float goodcontents, float badcontents, float badsurfaceflags, float attempts, float maxaboveground, float minviewdistance);

void dropclient_do(entity this);

bool dropclient_schedule(entity this);

string GetField_fullspawndata(entity e, string fieldname, bool vfspath);

void SendCSQCLightningBeam(vector v1, vector v2);

void dedicated_print(string input);

void set_anim(entity this, int frm, void(entity) tnk);
void set_animofs(entity this, int frm, int offs, void(entity) tnk); // because we can
// special hax version for weapons since they don't use .frame
void wep_set_anim(entity this, int frm, void(entity) tnk);

// intrusive lists

IntrusiveList g_damagedbycontents;
IntrusiveList g_moveables;
IntrusiveList g_vspheres;
IntrusiveList g_arms;
IntrusiveList g_runes;
STATIC_INIT(defs)
{
	g_damagedbycontents = IL_NEW();
	g_moveables = IL_NEW();
	g_vspheres = IL_NEW();
	g_arms = IL_NEW();
	g_runes = IL_NEW();
}
